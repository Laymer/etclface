
#
# etclface test suit.
#

package require etclface

set myname [info script]

set mynode	etclface1
set myhost	localhost
set myipaddr	127.0.0.1
set myalive	$mynode
set mynodename	"${mynode}@${myhost}"

set cookie	secretcookie
set timeout	5000

set remnode	erlnode
set remhost	localhost
set remnodename	"erlnode@localhost"
set remipaddr	127.0.0.1

# The array all_tests will be populated with test name/description
# entries below:
array set all_tests {}

# error report for investigation by user
# args are as generated by catch
proc error_report {result options} {
	puts stderr "=== result ========"
	puts stderr $result
	puts stderr "=== Error Trace ==="
	puts stderr $options
	puts stderr "==================="
}


array set all_tests {init_1 {etclface::init without args}}
proc init_1 {} {
	if [catch { set ec [etclface::init] } result] {
		if [string match {wrong # args:*} $result] { return }
		return -code error $result
	}
	return -code error {etclface::init with no args succeeded}
}

array set all_tests {init_2 {etclface::init without cookie}}
proc init_2 {} {
	if [catch { set ec [etclface::init $::mynode] } result] {
		return -code error $result
	}
	if [string match "ec0x*" $ec] {
		etclface::ec_free $ec
		return
	}
	return -code error $result
}

array set all_tests {init_3 {etclface::init with cookie}}
proc init_3 {} {
	if [catch { set ec [etclface::init $::mynode $::cookie] } result] {
		return -code error $result
	}
	if [string match "ec0x*" $ec] {
		etclface::ec_free $ec
		return
	}
	return -code error $result
}

array set all_tests {xinit_1 {etclface::xinit without args}}
proc xinit_1 {} {
	if [catch { set ec [etclface::xinit] } result] {
		if [string match {wrong # args:*} $result] { return }
		return -code error $result
	}
	return -code error {etclface::xinit with no args succeeded}
}

array set all_tests {xinit_2 {etclface::xinit without cookie}}
proc xinit_2 {} {
	if [catch { set ec [etclface::xinit $::myhost $::myalive $::mynodename $::myipaddr] } result] {
		return -code error $result
	}
	if [string match "ec0x*" $ec] {
		etclface::ec_free $ec
		return
	}
	return -code error $result
}

array set all_tests {xinit_3 {etclface::xinit with cookie}}
proc xinit_3 {} {
	if [catch { set ec [etclface::xinit $::myhost $::myalive $::mynodename $::myipaddr $::cookie] } result] {
		return -code error $result
	}
	if [string match "ec0x*" $ec] {
		etclface::ec_free $ec
		return
	}
	return -code error $result
}

array set all_tests {connect_1 {etclface::connect without arguments}}
proc connect_1 {} {
	if [catch { etclface::connect } result] {
		if [string match {wrong # args:*} $result] { return }
		return -code error $result
	}
	return -code error {connect with no args succeeded}
}

array set all_tests {connect_2 {etclface::connect with no timeout}}
proc connect_2 {} {
	if [catch {	set ec [etclface::init $::mynode $::cookie]
			set fd [etclface::connect $ec $::remnodename]
			} result] {
		return -code error $result
	}
	if [string is integer $fd] {
		etclface::ec_free $ec
		etclface::disconnect $fd
		return
	}
	return -code error "etclface::connect did not return an integer ($fd)"
}

array set all_tests {connect_3 {etclface::connect with timeout}}
proc connect_3 {} {
	if [catch {	set ec [etclface::init $::mynode $::cookie]
			set fd [etclface::connect $ec $::remnodename $::timeout]
			} result] {
		return -code error $result
	}
	if [string is integer $fd] {
		etclface::ec_free $ec
		etclface::disconnect $fd
		return
	}
	return -code error "etclface::connect did not return an integer ($fd)"
}

array set all_tests {connect_4 {etclface::connect with invalid timeout}}
proc connect_4 {} {
	if [catch {	set ec [etclface::init $::mynode $::cookie]
			set fd [etclface::connect $ec $::remnodename not_a_timeout]
			} result] {
		if [string match {expected integer but got *} $result] {
			if [string match {ec0x*} $ec] { etclface::ec_free $ec }
			return
		}
		return -code error $result
	}
	return -code error "etclface::connect with invalid timeout succeeded"
}

array set all_tests {xconnect_1 {etclface::xconnect without arguments}}
proc xconnect_1 {} {
	if [catch { etclface::xconnect } result] {
		if [string match {wrong # args:*} $result] { return }
		return -code error $result
	}
	return -code error {xconnect with no args succeeded}
}

array set all_tests {xconnect_2 {etclface::xconnect with no timeout}}
proc xconnect_2 {} {
	if [catch {	set ec [etclface::init $::mynode $::cookie]
			set fd [etclface::xconnect $ec $::remipaddr $::remnode]
			} result] {
		return -code error $result
	}
	if [string is integer $fd] {
		etclface::ec_free $ec
		etclface::disconnect $fd
		return
	}
	return -code error "etclface::xconnect did not return an integer ($fd)"
}

array set all_tests {xconnect_3 {etclface::xconnect with timeout}}
proc xconnect_3 {} {
	if [catch {	set ec [etclface::init $::mynode $::cookie]
			set fd [etclface::xconnect $ec $::remipaddr $::remnode $::timeout]
			} result] {
		return -code error $result
	}
	if [string is integer $fd] {
		etclface::ec_free $ec
		etclface::disconnect $fd
		return
	}
	return -code error "etclface::xconnect did not return an integer ($fd)"
}

array set all_tests {xconnect_4 {etclface::xconnect with invalid timeout}}
proc xconnect_4 {} {
	if [catch {	set ec [etclface::init $::mynode $::cookie]
			set fd [etclface::xconnect $ec $::remipaddr $::remnode not_a_timeout]
			} result] {
		if [string match {expected integer but got *} $result] {
			if [string match {ec0x*} $ec] { etclface::ec_free $ec }
			return
		}
		return -code error $result
	}
	return -code error "etclface::xconnect with invalid timeout succeeded"
}

array set all_tests {xbuff_1 {etclface::xb_new with bad arguments}}
proc xbuff_1 {} {
	if [catch { etclface::xb_new a_bad_argument } result ] {
		if [string match {Only -withversion*} $result] { return }
		return -code error $result
	}
	return -code error "etclface:xb_new with bad arguments succeeded!"
}

array set all_tests {xbuff_2 {etclface::xb_new no version}}
proc xbuff_2 {} {
	if [catch { set xb [etclface::xb_new] }] {
		return -code error $result
	}
	etclface::xb_free $xb
	return
}

array set all_tests {xbuff_3 {etclface::xb_new with version}}
proc xbuff_3 {} {
	if [catch { set xb [etclface::xb_new -withversion] } result] {
		return -code error $result
	}
	etclface::xb_free $xb
	return
}

array set all_tests {xbuff_4 {etclface::xb_show with bad argument}}
proc xbuff_4 {} {
	if [catch {etclface::xb_show a_bad_argument} result] {
		if [string match {Invalid xb handle} $result] { return }
		return -code error $result
	}
	return -code error "etclface:xb_show with bad argument succeeded!"
}

array set all_tests {xbuff_5 {etclface::xb_show with good argument}}
proc xbuff_5 {} {
	if [catch {	set xb [etclface::xb_new]
			etclface::xb_free $xb
			} result] {
		return -code error $result
	}
	return
}

array set all_tests {xbuff_6 {etclface::xb_free with good argument}}
proc xbuff_6 {} {
	if [catch {etclface::xb_free a_bad_argument} result] {
		if [string match {Invalid xb handle} $result] { return }
		return -code error $result
	}
	return -code error "etclface::xb_free with bad argument succeeded!"
}

array set all_tests {xbuff_7 {etclface::xb_free with good argument}}
proc xbuff_7 {} {
	if [catch {	set xb [etclface::xb_new]
			etclface::xb_free $xb
			} result] {
		return -code error $result
	}
	return
}

